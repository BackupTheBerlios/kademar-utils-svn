#!/bin/ash
# Initial script for Linux Live operating system
# Author: Tomas M <http://www.linux-live.org/>

export PATH=.:/:/usr/sbin:/usr/bin:/sbin:/bin

mount -n -t proc proc /proc
mount -n -t sysfs sysfs /sys
mount -n -o remount,rw /         # for the case we forgot rw boot option
ln -sf /proc/mounts /etc/mtab    # this allows us to use umount -a

. liblinuxlive # it requires proc to be mounted
echo
#header "starting Linux Live scripts <http://www.linux-live.org/>"
header " *  kademar Linux  *"
echo
# Don't print kernel messages to konsole now.
# Syslog will reset printk settings, no need to remember it here anymore.
echo "0" >/proc/sys/kernel/printk

# Find livecd data directory by searching for livecd.sgn file
SGN=$(cmdline_value sgnfile)
if [ "$SGN" = "" ]; then SGN=livecd.sgn; fi


#kademar language SUPPORT
for i in `cat /proc/cmdline`
do
    case $i in
    "lang=ca")
        lang="ca"
        break
    ;;
    "lang=es")
        lang="es"
        break
    ;;
    "lang=en")
        lang="en"
        break
    ;;
    esac
done
[ -z "$lang" ] && lang=en

case $lang in
    "ca")
        mesg_udev="engegant detector de dispositius Udev"
        msg_compcache="CompCache trobat"
        msg_sgn="cercat per data en el directori (cercant pel fitxer $SGN)"
        msg_found="trobat en"
        msg_setting="preparant els directoris pels canvis"
        msg_aufs="preparant directori union (usant aufs)"
        msg_ccache="activant suport a CompCache"
        msg_copy2ram="copiant data a RAM, pot trigar una estona..."
        msg_rootdirectory="canviant a directori arrel..."
        msg_final="engegant kademar Linux"
        msg_fatal="Se suposa que no has d'estar a aquest punt, alguna cosa ha anat malament!"
    ;;
    "es")
        mesg_udev="iniciando detector de dispositivos Udev"
        msg_compcache="CompCache encontrado"
        msg_sgn="buscando los datos en el directorio (buscando el fichero $SGN)"
        msg_found="encontrado en"
        msg_setting="preparando el directorio para los cambios"
        msg_aufs="preparando directorio union (usando aufs)"
        msg_ccache="activando soporte a CompCache"
        msg_copy2ram="copiando datos a RAM, puede tardar un poco..."
        msg_rootdirectory="cambiando a directorio raiz..."
        msg_final="iniciando kademar Linux"
        msg_fatal="Se supone que no debes estar en este punto, algo ha ido mal!"
    ;;
    *)
        mesg_udev="starting Udev function"
        msg_compcache="found CompCache"
        msg_sgn="looking for data directory (searching for $SGN file)"
        msg_found="found in"
        msg_setting="setting up directory for changes"
        msg_aufs="setup union directory (using aufs)"
        msg_ccache="activating CompCache support"
        msg_copy2ram="copying data to RAM, this may take some time..."
        msg_rootdirectory="changing root directory..."
        msg_final="starting kademar Linux"
        msg_fatal="You are not supposed to be here, something went wrong!"
    ;;
esac

#END LANGUAGE SUPPORT


# Load essential drivers, like CDROM drivers, aufs/squashfs etc,
# use mdev to create /dev/ devices and setup it as a hotplug-handler
modprobe_essential_modules

#kademar udev funtion
echolog "$mesg_udev"
udev_casero_kademar
debug_shell

mdev_start_hotplug

# /usr is compressed in initrd so it must be mounted from /usr.lzm
mount_initrd_loops

# Then load drivers for data storage and input devices
modprobe_usb_modules
modprobe_pcmcia_modules

debug_shell

#kademar  compcache
ccachedir="/lib/modules/`uname -r`/kernel/fs/compcache"
if [ -e "$ccachedir" ]; then
   echolog "$msg_compcache"
   for i in lzo1x_compress.ko lzo1x_decompress.ko tlsf.ko xvmalloc.ko compcache.ko
   do
      [ -e "$ccachedir/$i" ] && insmod "$ccachedir/$i"
   done
   #insmod "$ccachedir/compcache.ko" ccache_size_kbytes=128000
   #debug_shell
fi


# make sure ext3 partitions are not mounted using ext2 driver,
# and vfat partitions are not mounted using msdos driver
echo -e "ext3\next2\nvfat\n*" >/etc/filesystems

mkdir -p $UNION
mkdir -p $MEMORY

debug_shell

echolog "$msg_sgn"

# First, try from= boot argument, if given
DATAFROM=$(cmdline_value from)

if [ "$DATAFROM" ]; then
   DATAFROM=$(find_in_computer $DATAFROM)
   if [ "$DATAFROM" ]; then
      mount_device $DATAFROM $LOOPMOUNT # mount again, it may be loop device
      if [ $? -eq 0 -a "$(find_modules $LOOPMOUNT/$LIVECDNAME)" != "" ]; then
         echolog "$msg_found $DATAFROM"
         DATA=$LOOPMOUNT/$LIVECDNAME
      else
         fumount $LOOPMOUNT
	 fumount $MOUNTDIR/*
      fi
   fi
fi


if [ "$DATA" = "" ]; then
   # from= is not used or it didn't contain valid data
   debug_log Trying Second round of mount
   DATA=$(find_in_computer $LIVECDNAME/$SGN)
   DATA=$(dirname $DATA 2>/dev/null)
fi



#kademar
if [ "$DATA" = "" ]; then
   # from= is not used or it didn't contain valid data
   debug_log Trying first round of mount
   DATA=$(kademar_mount_function $LIVECDNAME/$SGN)
   DATA=$(dirname $DATA 2>/dev/null)
fi


if [ "$DATA" = "" ]; then fatal \
"$LIVECDNAME data not found.
You are maybe using an unsupported boot device (eg. SCSI or old PCMCIA).
Workaround: Copy the directory $LIVECDNAME from your boot device to an IDE/SATA
disk, eg. to /mnt/hda1/$LIVECDNAME or C:\\$LIVECDNAME. Then try to boot again."
fi

#kademar
debug_log "using $LIVECDNAME data from $DATA"

echo $DATA | cut -d/ -f3 > /data

#kademar  compcache
[ -e /dev/ramzswap0 ] && swapon /dev/ramzswap0 && echolog "$msg_ccache"


debug_shell

echolog "$msg_setting"
CHANGESVAL=$(cmdline_value changes)

if [ "$CHANGESVAL" ]; then
   CHANGESMNT=$(find_in_computer $CHANGESVAL)
   echolog $CHANGESMNT
fi

debug_shell

mount_device "$CHANGESMNT" $MEMORY # removes $MEMORY if CHANGESMNT is wrong

# test if the filesystem is writable so changes can be stored to it
touch $MEMORY/empty 2>/dev/null && \
rm -f $MEMORY/empty 2>/dev/null

# if changes can't be mounted or the filesystem is not writable,
# fallback to the default: tmpfs
if [ $? -ne 0 ]; then
   debug_log "changes not used or not writable, using memory only"
   fumount $MEMORY
   mkdir -p $MEMORY # mount_device might removed it

   RAMSIZE=$(cmdline_value ramsize)
   if [ "$RAMSIZE" = "" ]; then RAMSIZE="60%"; fi
   mount -t tmpfs -o "size=$RAMSIZE" tmpfs $MEMORY
   XINO=$MEMORY
else
   # So it is writable, we will keep the filesystem mounted.
   # Check if it supports links and chmod.
   # If not, overmount CHANGES using posixovl
   debug_log "testing the filesystem for posix compatibility"
   touch $MEMORY/.empty1 && \
   ln -sf $MEMORY/.empty1 $MEMORY/.empty2 2>/dev/null && \
   chmod +x $MEMORY/.empty1 2>/dev/null  && \
   test -x $MEMORY/.empty1 && \
   chmod -x $MEMORY/.empty1 2>/dev/null  && \
   test ! -x $MEMORY/.empty1 && \
   rm $MEMORY/.empty1 $MEMORY/.empty2 2>/dev/null

   if [ $? -ne 0 ]; then
      debug_log "not compatible - starting posixovl"
      rm $MEMORY/.empty1 $MEMORY/.empty2 2>/dev/null
      mkdir -p $CHANGES
      posixovl -F $CHANGES
   fi
fi

# $UNION will be used as a root directory, livecd modules will be added soon
echolog "$msg_aufs"

mkdir -p $CHANGES
mkdir -p $IMAGES

debug_shell

# store the xino file in memory in all cases, it's faster and safer
if [ "$XINO" != "$MEMORY" ]; then
   mkdir -p $XINO
   mount -n -t tmpfs tmpfs $XINO
fi

# mount aufs using the writable branch as the first one (leftmost/topmost)
mount -t aufs -o nowarn_perm,xino=$XINO/.aufs.xino,br:$CHANGES=rw aufs $UNION
if [ $? -ne 0 ]; then dmesg | tail -n 1; fatal "can't setup union (aufs)"; fi

debug_shell


# If toram or copy2ram boot parameter is present, copy all fs modules to RAM.
# (skip modules from /optional/ which are not listed in load= boot option)
# Finaly modify DATA variable so it will point to correct directory
if [ "$(cmdline_parameter toram)" != "" -o "$(cmdline_parameter copy2ram)" != "" ]; then
   echolog "$msg_copy2ram"
   mkdir -p $COPY2RAM

   # make sure it's in RAM even with changes= parameter
   if [ "$CHANGESMNT" ]; then mount -t tmpfs -o "size=$RAMSIZE" tmpfs $COPY2RAM; fi
   copy_to_ram $DATA $COPY2RAM

   cd_autoeject 1
   fumount $DATA
   fumount $MOUNTDIR/*
   rmdir $MOUNTDIR/* 2>/dev/null # mounted device names are empty, remove them
   DATA=$COPY2RAM
   cd_autoeject 0
   touch /copy2ram
fi

debug_shell

# DATA contains path to the base directory of all fs modules which need
# to be mounted and inserted into live filesystem. Do it now.
debug_log "inserting all modules and creating live filesystem"
union_insert_modules $UNION $DATA $IMAGES

# the $MEMORY directory can contain $MEMORY/modules too
# in the case if changes= boot argument is used. If not, it doesn't hurt
union_insert_modules $UNION $MEMORY $IMAGES

debug_shell

debug_log "copying content of rootcopy directory"
cp -af $DATA/rootcopy/* $UNION 2>/dev/null # may be empty

# TODO: if copy2ram is used, there is no need to preserve the original in memory anymore
#if [ "$DATA" = "$COPY2RAM" ]; then 
#    rm from memory once ??
#fi

debug_log "copying liblinuxlive library to union"
cp -af /liblinuxlive $UNION/usr/lib/

debug_shell

#echolog "creating /etc/fstab"
touch $UNION/etc/fstab
#fstab_update $UNION

# everything is ready now, so we may unload unused kernel modules
# and do some cleanup, unmount few things which are no longer needed.
rmmod_unused_modules
fumount /usr
fumount /sys

# More likely these directories aren't there.
# Even if they are, this won't hurt.
mkdir -p $UNION/boot
mkdir -p $UNION/proc
mkdir -p $UNION/sys
mkdir -p $UNION/dev
mkdir -p $UNION/tmp
chmod 1777 $UNION/tmp

# Boot will contain whatever was in ./boot directory in the bootable media
# Error output goes to null, as nothing is mounted with copy2ram

#kademar
#mount -n -o rbind $(dirname $DATA)/boot $UNION/boot 2>/dev/null

debug_shell

# Union contains all the files and directories unioned from all modules.
# Change root directory to it, and move initrd's root to /mnt/live/initramdisk
# Finaly execute /sbin/init to start the distribution.
echolog "$msg_rootdirectory"

cd $UNION
mkdir -p $INITRAMDISK

#kademar /bin/bash immortal shells for live-cd ONLY
rm -f etc/inittab

#normal and adriane inittab support
[ -n "`grep adriane /proc/cmdline`" ] && adriane=".adriane"
cp /inittab$adriane etc/inittab



# Copy all dev files (found by mdev) to unioned dev directory
# so at least disk devices exist (your Linux may need them).
# Two exceptions, do not copy pty* and tty* devs.
if [ ! -e /dev/console ]; then mknod /dev/console c 5 1; fi
cp -fdR /dev . 2>/dev/null

# find chroot and init
if [ -x bin/chroot ]; then  CHROOT=bin/chroot; fi
if [ -x sbin/chroot ]; then  CHROOT=sbin/chroot; fi
if [ -x usr/bin/chroot ]; then  CHROOT=usr/bin/chroot; fi
if [ -x usr/sbin/chroot ]; then CHROOT=usr/sbin/chroot; fi
if [ "$CHROOT" = "" ]; then fatal "Can't find executable chroot command"; fi

if [ -x bin/init ]; then INIT=bin/init; fi
if [ -x sbin/init ]; then INIT=sbin/init; fi
if [ "$INIT" = "" ]; then fatal "Can't find executable init command"; fi

# time to end Linux Live scripts and start the distribution itself,
# using /sbin/init or whatever was found.
header "$msg_final"

debug_shell

mount -n -o remount,ro aufs .

# We will copy init from the distro to initrd (there should be 2MB free)
# This allows us to use the cleanup script during reboot, as init will be
# started from memory and not from the union and /union will not be busy.

cp -af $INIT /bin
if [ $? -eq 0 ]; then
   pivot_root . $INITRAMDISK
   exec $CHROOT . $INITRAMDISK/bin/init <dev/console >dev/console 2>&1
else # If copying fails, start init directly.
   pivot_root . $INITRAMDISK
   exec $CHROOT . $INIT <dev/console >dev/console 2>&1
fi

header "!!ERROR!!"
fatal "$msg_fatal"
